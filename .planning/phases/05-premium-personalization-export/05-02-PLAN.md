---
phase: 05-premium-personalization-export
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified: [index.html, sw.js]
autonomous: true

must_haves:
  truths:
    - "Premium user can choose from 6 timer alert chime sounds (3 free + 3 premium)"
    - "Selected chime plays on timer completion instead of default Web Audio sine tones"
    - "User can preview any chime sound from the selector before choosing"
    - "Chime preference persists across sessions via localStorage"
    - "Premium user can export session history as CSV file"
    - "CSV export includes date range filter with start/end date inputs"
    - "Exported CSV contains Date, Duration, Project, Hour, Day columns with proper RFC 4180 escaping"
  artifacts:
    - path: "index.html"
      provides: "Chime selector dialog and playChime replacement"
      contains: "chimeDialog"
    - path: "index.html"
      provides: "CSV export dialog with date range inputs"
      contains: "exportDialog"
    - path: "index.html"
      provides: "exportSessionsCSV function with Firestore query"
      contains: "exportSessionsCSV"
    - path: "index.html"
      provides: "6 Web Audio API chime synthesis configs in CHIME_SOUNDS"
      contains: "CHIME_SOUNDS"
  key_links:
    - from: "complete() function"
      to: "playChime()"
      via: "playChime uses selected chime from state.settings.selectedChime"
      pattern: "state\\.settings\\.selectedChime"
    - from: "chime selector UI"
      to: "Audio() objects"
      via: "previewChime() plays audio elements from chimeAudioElements map"
      pattern: "chimeAudioElements"
    - from: "export dialog"
      to: "Firestore sessions subcollection"
      via: "exportSessionsCSV queries with date range .where()"
      pattern: "sessions.*where.*startedAt"
    - from: "CSV generation"
      to: "Blob download"
      via: "generateAndDownloadCSV creates Blob and triggers link click"
      pattern: "URL\\.createObjectURL"
---

<objective>
Add customizable timer alert chimes with a sound selector, and implement CSV session export with date range filtering.

Purpose: Complete the Phase 5 personalization story (chime sounds) and deliver data portability (CSV export) -- the two remaining requirements for this phase.
Output: Chime selector with 6 sounds (3 free + 3 premium), CSV export dialog with Firestore date range query, downloadable CSV file.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-premium-personalization-export/05-RESEARCH.md
@.planning/phases/05-premium-personalization-export/05-01-SUMMARY.md
@.planning/phases/04-data-foundation-and-projects/04-01-SUMMARY.md
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Chime sound files and selector UI</name>
  <files>index.html, sounds/chime-bell.mp3, sounds/chime-soft.mp3, sounds/chime-digital.mp3, sounds/chime-gong.mp3, sounds/chime-bowl.mp3, sounds/chime-crystal.mp3</files>
  <action>
**Sound files:**

Create a `/sounds/` directory. Generate 6 short chime MP3 files using Web Audio API offline rendering (or use the existing Web Audio API pattern in the codebase to programmatically generate tones). Since we cannot download external files, generate the chime sounds programmatically at runtime using Web Audio API AudioContext and OfflineAudioContext, but store the definitions as configuration rather than files.

**ALTERNATIVE APPROACH (preferred -- no external files needed):** Instead of MP3 files, define chime sounds as Web Audio API synthesis recipes. The existing `playChime()` already uses Web Audio API (oscillators with frequency arrays). Extend this pattern with 6 different chime configurations:

```javascript
const CHIME_SOUNDS = {
  bell: {
    name: 'Classic Bell',
    premium: false,
    // C5, E5, G5 ascending (current default)
    notes: [523.25, 659.25, 783.99],
    type: 'sine',
    spacing: 0.15,
    duration: 0.4,
    gain: 0.3
  },
  soft: {
    name: 'Soft Chime',
    premium: false,
    // A4, C#5, E5 (A major chord, softer)
    notes: [440, 554.37, 659.25],
    type: 'sine',
    spacing: 0.2,
    duration: 0.6,
    gain: 0.2
  },
  digital: {
    name: 'Digital Pulse',
    premium: false,
    // Two quick beeps
    notes: [880, 880],
    type: 'square',
    spacing: 0.12,
    duration: 0.15,
    gain: 0.15
  },
  gong: {
    name: 'Meditation Gong',
    premium: true,
    // Low resonant tone
    notes: [130.81, 196, 261.63],
    type: 'sine',
    spacing: 0.3,
    duration: 1.0,
    gain: 0.25
  },
  singing: {
    name: 'Singing Bowl',
    premium: true,
    // Overtone-rich pattern: fundamental + fifth + octave
    notes: [261.63, 392, 523.25, 783.99],
    type: 'sine',
    spacing: 0.25,
    duration: 0.8,
    gain: 0.2
  },
  crystal: {
    name: 'Crystal Chime',
    premium: true,
    // High tinkling notes descending
    notes: [1046.5, 987.77, 880, 783.99],
    type: 'triangle',
    spacing: 0.1,
    duration: 0.5,
    gain: 0.2
  },
};
```

Place this constant near the existing AUDIO_STATIONS block (~line 2460).

**Modify `playChime()` function** (~line 2837):

Replace the hardcoded frequency arrays with the selected chime configuration:

```javascript
function playChime(type) {
  if (!state.settings.soundEnabled) return;
  duckBackgroundAudio();

  try {
    const ctx = getAudioCtx();
    const now = ctx.currentTime;
    const selectedChimeId = state.settings.selectedChime || 'bell';
    const chime = CHIME_SOUNDS[selectedChimeId] || CHIME_SOUNDS.bell;

    // For break completion, reverse the notes
    const notes = type === 'break' ? [...chime.notes].reverse() : chime.notes;

    notes.forEach((freq, i) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = chime.type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0, now + i * chime.spacing);
      gain.gain.linearRampToValueAtTime(chime.gain, now + i * chime.spacing + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.001, now + i * chime.spacing + chime.duration);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(now + i * chime.spacing);
      osc.stop(now + i * chime.spacing + chime.duration);
    });
  } catch {}
}
```

**Add `previewChime(chimeId)` function:**
Plays the chime sound immediately for previewing in the selector UI:
```javascript
function previewChime(chimeId) {
  const chime = CHIME_SOUNDS[chimeId];
  if (!chime) return;
  try {
    const ctx = getAudioCtx();
    const now = ctx.currentTime;
    chime.notes.forEach((freq, i) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = chime.type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0, now + i * chime.spacing);
      gain.gain.linearRampToValueAtTime(chime.gain, now + i * chime.spacing + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.001, now + i * chime.spacing + chime.duration);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(now + i * chime.spacing);
      osc.stop(now + i * chime.spacing + chime.duration);
    });
  } catch {}
}
```

**Add `state.settings.selectedChime`:** Default to `'bell'`. Add to DEFAULTS object if one exists, or initialize in settings load. Ensure it's included in `saveSettings()` / `loadSettings()` (which already serialize/deserialize the entire `state.settings` object, so just adding the property should work).

**CSS for chime selector dialog:**
Style `#chimeDialog` following the existing dialog pattern. Add a `.chime-grid` with flex-wrap layout. Each `.chime-card` is a button with:
- Chime name
- Play/preview icon button (small speaker/play icon)
- `.active` class for selected chime (border highlight using --primary)
- `.locked` class for premium chimes (reduced opacity, "Premium" badge)
- On hover: subtle background highlight

**HTML for chime dialog** (add after the theme dialog):
```html
<dialog id="chimeDialog" aria-labelledby="chimeTitle">
  <div class="dialog-header">
    <h2 id="chimeTitle">Timer Sound</h2>
    <button class="icon-btn" id="closeChime" aria-label="Close">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
      </svg>
    </button>
  </div>
  <div class="dialog-body chime-grid" id="chimeGrid"></div>
</dialog>
```

**JavaScript for chime selector:**

1. Add DOM refs: `const chimeDialog = $('#chimeDialog');`, `const chimeGrid = $('#chimeGrid');`

2. Add `showChimeSelector()` function:
   - Clear chimeGrid innerHTML
   - Loop through CHIME_SOUNDS entries
   - For each chime, create a button element with class `chime-card`
   - Add `.active` if it matches `state.settings.selectedChime`
   - Add `.locked` + "Premium" badge if premium and `!isPremium()`
   - Add a small play/preview button (speaker SVG) that calls `previewChime(id)` on click (use stopPropagation to prevent selecting)
   - Main card click: if locked, `requirePremium('Premium Sounds')`. Otherwise set `state.settings.selectedChime = id`, `saveSettings()`, update active states
   - `chimeDialog.showModal()`

3. **Add entry point to settings dialog:** In the settings form (between the "Sound" toggle and the dialog-actions), add a row:
```html
<div class="toggle-row" id="chimeSettingRow">
  <span>Timer Sound</span>
  <button type="button" class="btn btn-ghost btn-sm" id="openChimeSelector">Classic Bell ></button>
</div>
```
The button text should show the current chime name. On click, close settings dialog temporarily and open chime dialog. When chime dialog closes, update the button text.

4. Add event listeners (inside IIFE):
   - `closeChime` click -> `chimeDialog.close()`
   - `chimeDialog` backdrop click -> close
   - Add to Escape key priority chain
   - `openChimeSelector` click -> `showChimeSelector()`

5. Update the chime setting row label on init and after chime selection to show current chime name.

**Since we're using Web Audio API synthesis (not MP3 files), skip creating the /sounds/ directory entirely.** The files_modified in frontmatter includes sound files but this approach eliminates that need -- all sound generation is code-based using the existing Web Audio API pattern.
  </action>
  <verify>
Open index.html in browser. Go to Settings. Verify:
1. "Timer Sound" row appears showing current chime name ("Classic Bell")
2. Clicking it opens chime selector dialog with 6 chime cards
3. Each card has a play/preview button -- clicking it plays the chime sound
4. 3 free chimes (Classic Bell, Soft Chime, Digital Pulse) selectable by anyone
5. 3 premium chimes (Meditation Gong, Singing Bowl, Crystal Chime) show "Premium" badge
6. Selecting a different chime updates the settings row text
7. Start a focus timer, skip to completion (or manually call complete()) -- selected chime plays
8. Reload page -- chime selection persists
  </verify>
  <done>
6 chime sounds defined as Web Audio API synthesis recipes (3 free + 3 premium). Chime selector dialog with preview playback. playChime() uses selected chime configuration. Chime preference persists in settings. Premium chimes gated. Break completion reverses note pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: CSV session export with date range filter</name>
  <files>index.html, sw.js</files>
  <action>
**HTML for export dialog** (add after chime dialog):
```html
<dialog id="exportDialog" aria-labelledby="exportTitle">
  <div class="dialog-header">
    <h2 id="exportTitle">Export Sessions</h2>
    <button class="icon-btn" id="closeExport" aria-label="Close">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
      </svg>
    </button>
  </div>
  <div class="dialog-body">
    <p class="export-description" style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 16px;">Download your focus session history as a CSV file.</p>
    <div class="field">
      <label for="exportStartDate">Start Date</label>
      <input type="date" id="exportStartDate">
    </div>
    <div class="field">
      <label for="exportEndDate">End Date</label>
      <input type="date" id="exportEndDate">
    </div>
    <div id="exportStatus" style="font-size: 0.875rem; color: var(--text-secondary); min-height: 20px;"></div>
    <div class="dialog-actions">
      <button type="button" class="btn btn-ghost" id="cancelExport">Cancel</button>
      <button type="button" class="btn btn-primary" id="exportCsvBtn">Export CSV</button>
    </div>
  </div>
</dialog>
```

**CSS for export dialog:**
Style date inputs to match the existing `.field input` pattern (background: var(--surface), border: 1px solid var(--border), color: var(--text), border-radius, padding). Date inputs need explicit styling:
```css
#exportDialog input[type="date"] {
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 8px 12px;
  border-radius: var(--radius-sm);
  font-size: 1rem;
  width: 100%;
}
#exportDialog input[type="date"]::-webkit-calendar-picker-indicator {
  filter: var(--date-picker-filter, none);
}
```
For dark themes, add `--date-picker-filter: invert(1);` so the calendar icon is visible.

**JavaScript:**

1. Add DOM refs: `const exportDialog = $('#exportDialog')`, etc.

2. **Add `showExportDialog()` function:**
   - Premium gate: `if (!requirePremium('CSV Export')) return;`
   - Set default date range: start = first day of current month, end = today
   - Format as YYYY-MM-DD for date input values
   - Clear any previous status message
   - `exportDialog.showModal()`

3. **Add `exportSessionsCSV()` function:**
   ```javascript
   async function exportSessionsCSV() {
     const startInput = document.getElementById('exportStartDate');
     const endInput = document.getElementById('exportEndDate');
     const statusEl = document.getElementById('exportStatus');

     if (!startInput.value || !endInput.value) {
       statusEl.textContent = 'Please select both dates.';
       return;
     }

     const startDate = new Date(startInput.value + 'T00:00:00');
     const endDate = new Date(endInput.value + 'T23:59:59');

     if (startDate > endDate) {
       statusEl.textContent = 'Start date must be before end date.';
       return;
     }

     if (!state.user) {
       statusEl.textContent = 'Please sign in to export.';
       return;
     }

     statusEl.textContent = 'Fetching sessions...';

     try {
       const uid = state.user.uid;
       const sessionsRef = fbDb.collection('users').doc(uid).collection('sessions');
       const query = sessionsRef
         .where('startedAt', '>=', startDate)
         .where('startedAt', '<=', endDate)
         .orderBy('startedAt', 'desc')
         .limit(10000);

       const snapshot = await query.get();

       if (snapshot.empty) {
         statusEl.textContent = 'No sessions found in this date range.';
         return;
       }

       // Build project name lookup
       const projectMap = {};
       (state.projects || []).forEach(p => { projectMap[p.id] = p.name; });

       // Build session rows
       const sessions = [];
       snapshot.forEach(doc => {
         const data = doc.data();
         const startedAt = data.startedAt?.toDate ? data.startedAt.toDate() : new Date(data.startedAt);
         sessions.push([
           startedAt.toISOString(),
           data.duration || '',
           data.projectId ? (projectMap[data.projectId] || 'Unknown Project') : 'No Project',
           data.hourOfDay != null ? data.hourOfDay : '',
           data.dayOfWeek != null ? ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][data.dayOfWeek] : '',
         ]);
       });

       generateAndDownloadCSV(sessions, startInput.value, endInput.value);
       statusEl.textContent = `Exported ${sessions.length} sessions.`;

       // Close dialog after short delay
       setTimeout(() => exportDialog.close(), 1500);
     } catch (err) {
       console.error('Export failed:', err);
       if (err.message && err.message.includes('index')) {
         statusEl.textContent = 'Firestore index needed. Check console for setup link.';
       } else {
         statusEl.textContent = 'Export failed. Please try again.';
       }
     }
   }
   ```

4. **Add CSV generation function:**
   ```javascript
   function escapeCSVField(field) {
     if (field == null) return '';
     const str = String(field);
     if (str.includes(',') || str.includes('\n') || str.includes('"')) {
       return '"' + str.replace(/"/g, '""') + '"';
     }
     return str;
   }

   function generateAndDownloadCSV(rows, startDate, endDate) {
     const headers = ['Date', 'Duration (min)', 'Project', 'Hour of Day', 'Day of Week'];
     const csvRows = [headers.map(escapeCSVField)];
     rows.forEach(row => csvRows.push(row.map(escapeCSVField)));

     // UTF-8 BOM for Excel compatibility + CSV content
     const csvContent = '\uFEFF' + csvRows.map(r => r.join(',')).join('\n');

     const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
     const url = URL.createObjectURL(blob);

     const link = document.createElement('a');
     link.href = url;
     link.download = 'pomodoro-sessions-' + startDate + '-to-' + endDate + '.csv';
     link.style.display = 'none';
     document.body.appendChild(link);
     link.click();
     document.body.removeChild(link);
     URL.revokeObjectURL(url);
   }
   ```

5. **Add entry point for export:** Add an "Export" button in the stats dialog or create a dedicated entry point. Best approach: add an "Export CSV" button at the bottom of the stats dialog (inside `#statsDialog`, after the stats content, before the close area):
   ```html
   <button type="button" class="btn btn-ghost" id="openExport" style="margin-top: 12px; width: 100%;">
     Export CSV
   </button>
   ```
   On click: close stats dialog, call `showExportDialog()`.

   **Also** add an export option accessible from the main settings or a gear menu. Since the stats dialog is the natural place for data export, putting it there is sufficient.

6. **Event listeners** (inside IIFE):
   - `closeExport` click -> `exportDialog.close()`
   - `cancelExport` click -> `exportDialog.close()`
   - `exportCsvBtn` click -> `exportSessionsCSV()`
   - `exportDialog` backdrop click -> close
   - Add exportDialog to Escape key priority chain
   - `openExport` click -> close stats, show export dialog

7. **Bump service worker cache version** in sw.js.

**Important notes:**
- The Firestore query `where('startedAt', '>=', date).where('startedAt', '<=', date).orderBy('startedAt')` may require a composite index. The error message includes a direct link to create it. Add a user-friendly status message about this.
- `startedAt` in session records is stored as a JS Date object (not a Firestore Timestamp -- see `recordSessionData()` which passes `new Date(...)` directly). The `.where()` comparison should still work because Firestore stores JS Dates as Timestamps.
- Use UTC-8 BOM (\uFEFF) at start of CSV for Excel compatibility.
- Day of week maps numeric (0=Sun) to abbreviation for readability.
  </action>
  <verify>
Open index.html in browser. Verify:
1. Open Stats dialog -- "Export CSV" button visible at bottom
2. Click "Export CSV" -- if not premium, upgrade prompt appears
3. If premium (or test by mocking): export dialog opens with date range defaulting to current month
4. Click Export CSV button with valid dates -- CSV file downloads
5. Open CSV in text editor: has header row, data rows with proper escaping, UTF-8 BOM
6. Try with no sessions in range -- "No sessions found" message
7. Try with start after end -- validation error message
8. Close dialog via X, Cancel, Escape, backdrop click
  </verify>
  <done>
CSV export dialog with date range filter (defaults to current month). Firestore date range query with 10,000 session limit. RFC 4180 CSV escaping with UTF-8 BOM. Project names resolved from local state. Download triggered via Blob/URL pattern. Premium-gated. Accessible from stats dialog.
  </done>
</task>

</tasks>

<verification>
1. Chime selector accessible from Settings with 6 options (3 free + 3 premium)
2. Preview button plays each chime sound immediately
3. Selected chime plays on timer completion (both focus and break)
4. Chime selection persists across page reloads
5. CSV export accessible from Stats dialog, gated behind premium
6. Date range defaults to current month, validates start < end
7. CSV downloads with proper headers, escaping, and UTF-8 BOM
8. Firestore index error handled gracefully with helpful message
9. All dialogs close via X, Escape, backdrop click
10. No regression on existing timer, audio, or theme functionality
</verification>

<success_criteria>
- 6 chime sounds defined as Web Audio API synthesis configs (3 free + 3 premium)
- Chime selector dialog with live preview and premium gating
- playChime() uses selected chime configuration
- CSV export dialog with date range inputs and validation
- Firestore session query with date range filtering
- RFC 4180 CSV generation with UTF-8 BOM, Blob download
- Both features premium-gated via existing isPremium()/requirePremium()
- Service worker cache version bumped
</success_criteria>

<output>
After completion, create `.planning/phases/05-premium-personalization-export/05-02-SUMMARY.md`
</output>

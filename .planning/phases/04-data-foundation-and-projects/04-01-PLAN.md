---
phase: 04-data-foundation-and-projects
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [index.html, sw.js]
autonomous: true

must_haves:
  truths:
    - "Every completed focus session creates a session record in Firestore subcollection"
    - "Session record contains startedAt, duration, projectId, taskId, hourOfDay, dayOfWeek"
    - "Existing daily aggregate stats (dailyCounts, dailyMinutes) continue to work unchanged"
    - "Session recording uses batch writes so session + stats are atomic"
    - "State object includes projects array, activeProjectId, and currentTaskId fields"
  artifacts:
    - path: "index.html"
      provides: "recordSessionData function, state extensions, STORAGE_KEYS.projects"
      contains: "recordSessionData"
    - path: "index.html"
      provides: "State with projects, activeProjectId, currentTaskId"
      contains: "activeProjectId"
  key_links:
    - from: "timer completion handler (line ~3317)"
      to: "recordSessionData()"
      via: "called alongside updateFirestoreOnComplete()"
      pattern: "recordSessionData"
    - from: "recordSessionData()"
      to: "users/{uid}/sessions/{sessionId}"
      via: "Firestore batch write"
      pattern: "batch\\.set.*sessionRef"
---

<objective>
Add session-level data recording to every completed focus session, creating the data foundation that powers all future analytics and export features.

Purpose: DATA-01, DATA-02, DATA-03 -- granular session data in Firestore without breaking existing stats.
Output: `recordSessionData()` function called on every focus completion, writing session subcollection docs atomically with existing stats updates.
</objective>

<execution_context>
@/Users/user/.claude/agents/gsd-executor.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-foundation-and-projects/04-RESEARCH.md
@.planning/phases/03-payment-infrastructure-and-feature-gating/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend state object and add session recording function</name>
  <files>index.html</files>
  <action>
    1. Extend the `state` object (line ~2320) with three new fields:
       - `projects: []` -- array of `{ id, name, createdAt }` objects
       - `activeProjectId: null` -- currently selected project ID
       - `currentTaskId: null` -- tracks which task is being worked on (populated when timer starts)

    2. Add `projects` key to `STORAGE_KEYS` (line ~2182):
       ```
       projects: 'pomodoro-projects',
       ```

    3. Add `loadProjects()` and `saveProjects()` functions after the existing `saveTasks()` function (line ~2394):
       - `loadProjects()`: Read from localStorage, parse JSON into `state.projects`
       - `saveProjects()`: Write `state.projects` to localStorage as JSON

    4. Create `recordSessionData()` async function. Place it AFTER the existing `updateFirestoreOnComplete()` function (line ~3139). Implementation:
       - Guard: `if (!state.user || state.mode !== 'focus') return;`
       - Generate session ID: `const sessionId = crypto.randomUUID();`
       - Build session document path: `fbDb.collection('users').doc(uid).collection('sessions').doc(sessionId)`
       - Session data object:
         ```
         {
           startedAt: firebase.firestore.FieldValue.serverTimestamp(),
           duration: state.settings.focusDuration,
           projectId: state.activeProjectId || null,
           taskId: state.currentTaskId || null,
           hourOfDay: new Date().getHours(),
           dayOfWeek: new Date().getDay(),
           createdAt: firebase.firestore.FieldValue.serverTimestamp()
         }
         ```
       - Use `fbDb.batch()` for atomic write:
         - `batch.set(sessionRef, sessionData)`
         - `batch.set(userRef, { ...existing stats update fields... }, { merge: true })`
       - Wrap in try/catch, console.error on failure, never throw (don't break user flow)

    IMPORTANT: The batch write in `recordSessionData()` should include the SAME aggregate stats logic currently in `updateFirestoreOnComplete()` (dailyCounts, dailyMinutes, totalSessions, totalMinutes, etc.). This means `recordSessionData()` REPLACES `updateFirestoreOnComplete()` -- it does everything that function does PLUS the session subcollection write, all in one atomic batch.

    However, note the existing `updateFirestoreOnComplete()` does a read-then-write pattern (reads current cloud data, then writes). The research recommends using `FieldValue.increment()` instead, which is atomic and avoids the read. Refactor to use `FieldValue.increment()` for dailyCounts, dailyMinutes, totalSessions, totalMinutes. Keep the `{ merge: true }` on the user doc set.

    The refactored approach:
    ```javascript
    const userUpdate = {
      [`dailyCounts.${today}`]: firebase.firestore.FieldValue.increment(1),
      [`dailyMinutes.${today}`]: firebase.firestore.FieldValue.increment(state.settings.focusDuration),
      totalSessions: firebase.firestore.FieldValue.increment(1),
      totalMinutes: firebase.firestore.FieldValue.increment(state.settings.focusDuration),
      displayName: state.user.displayName || '',
      photoURL: state.user.photoURL || '',
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    };
    batch.set(userRef, userUpdate, { merge: true });
    ```

    Note: Using dot-notation keys like `dailyCounts.${today}` with `set({ merge: true })` updates only that nested field. This is equivalent to `update()` but works even if the document doesn't exist yet.
  </action>
  <verify>
    Search index.html for `recordSessionData` -- function must exist.
    Search for `state.projects` and `state.activeProjectId` and `state.currentTaskId` in state object.
    Search for `crypto.randomUUID` -- must be used for session IDs.
    Search for `batch.commit` -- must use batch writes.
    Search for `FieldValue.increment` -- must use atomic increments.
    Search for `STORAGE_KEYS` -- must include `projects` key.
  </verify>
  <done>
    `recordSessionData()` function exists with batch write (session subcollection + aggregate stats).
    State object extended with projects, activeProjectId, currentTaskId.
    STORAGE_KEYS includes projects.
    loadProjects/saveProjects functions exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire session recording into timer completion and add saveProjects to Firestore</name>
  <files>index.html, sw.js</files>
  <action>
    1. In the timer completion handler (line ~3303, inside `if (state.mode === 'focus')`):
       - Replace `updateFirestoreOnComplete().then(() => loadLeaderboard());` with:
         `recordSessionData().then(() => loadLeaderboard());`
       - This single call now handles both session recording AND aggregate stats atomically.
       - Remove or comment out the old `updateFirestoreOnComplete()` function since `recordSessionData()` replaces it.

    2. Add `saveProjectsToFirestore()` async function (near the other Firestore functions):
       - Writes `state.projects` array to the user document: `fbDb.collection('users').doc(uid).set({ projects: state.projects, updatedAt: serverTimestamp() }, { merge: true })`
       - Guard: `if (!state.user) return;`
       - Wrap in try/catch, silent fail

    3. Add `loadProjectsFromFirestore()` async function:
       - Reads user document, extracts `data.projects || []`
       - Sets `state.projects = data.projects || []`
       - Calls `saveProjects()` (localStorage) to cache locally
       - Guard: `if (!state.user) return;`

    4. Wire `loadProjectsFromFirestore()` into the auth state handler -- call it when user signs in, alongside the existing `pullStatsFromFirestore()` call. Find where `pullStatsFromFirestore()` is called after sign-in and add `loadProjectsFromFirestore()` nearby.

    5. Call `loadProjects()` in the `init()` function alongside existing `loadTasks()`, `loadSettings()`, `loadStats()` calls.

    6. Set `state.currentTaskId` when timer starts: In the `start()` function, find where the timer begins. Before the timer interval starts, check if there's a first incomplete task: `state.currentTaskId = state.tasks.find(t => !t.completed)?.id || null;`. This captures which task the user is working on.

    7. Bump `CACHE_NAME` in sw.js from `'pomodoro-v39'` to `'pomodoro-v40'`.
  </action>
  <verify>
    Search for `recordSessionData()` call in the timer completion section (should replace `updateFirestoreOnComplete`).
    Search for `saveProjectsToFirestore` and `loadProjectsFromFirestore` functions.
    Search for `loadProjects()` in init section.
    Search for `currentTaskId` assignment in start function.
    Verify sw.js contains `pomodoro-v40`.
    Verify `updateFirestoreOnComplete` is removed or commented out.
  </verify>
  <done>
    Timer completion calls `recordSessionData()` instead of `updateFirestoreOnComplete()`.
    Projects sync to/from Firestore on auth state changes.
    Projects load from localStorage on init.
    currentTaskId set to first incomplete task when timer starts.
    Service worker cache version bumped.
    Existing daily stats still update correctly (via FieldValue.increment in batch).
  </done>
</task>

</tasks>

<verification>
1. `recordSessionData` function exists and uses `fbDb.batch()` with both session subcollection write and user aggregate update
2. Timer completion handler calls `recordSessionData()` (not `updateFirestoreOnComplete()`)
3. `state` object has `projects: []`, `activeProjectId: null`, `currentTaskId: null`
4. `STORAGE_KEYS` includes `projects`
5. `loadProjects()`, `saveProjects()`, `saveProjectsToFirestore()`, `loadProjectsFromFirestore()` all exist
6. `FieldValue.increment` used for atomic counter updates (not read-modify-write)
7. sw.js `CACHE_NAME` is `'pomodoro-v40'`
</verification>

<success_criteria>
- Session recording function creates Firestore subcollection documents atomically with stats
- State extended for projects and active project tracking
- Projects persist in localStorage and sync to Firestore
- Existing daily stats continue to work (no breaking changes)
- No new UI added (data layer only)
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-foundation-and-projects/04-01-SUMMARY.md`
</output>

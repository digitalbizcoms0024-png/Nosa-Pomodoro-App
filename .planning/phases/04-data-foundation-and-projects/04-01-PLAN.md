---
phase: 04-data-foundation-and-projects
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [index.html, sw.js]
autonomous: true

must_haves:
  truths:
    - "Every completed focus session creates a session record in Firestore subcollection"
    - "Session record contains startedAt, duration, projectId, taskId, hourOfDay, dayOfWeek"
    - "startedAt reflects when the timer was STARTED, not when the session completed"
    - "Existing daily aggregate stats (dailyCounts, dailyMinutes) continue to work unchanged"
    - "Session recording uses batch writes so session + stats are atomic"
    - "State object includes projects array, activeProjectId, currentTaskId, and sessionStartTime fields"
  artifacts:
    - path: "index.html"
      provides: "recordSessionData function, state extensions, STORAGE_KEYS.projects"
      contains: "recordSessionData"
    - path: "index.html"
      provides: "State with projects, activeProjectId, currentTaskId, sessionStartTime"
      contains: "activeProjectId"
  key_links:
    - from: "timer completion handler (line ~3317)"
      to: "recordSessionData()"
      via: "called alongside updateFirestoreOnComplete()"
      pattern: "recordSessionData"
    - from: "recordSessionData()"
      to: "users/{uid}/sessions/{sessionId}"
      via: "Firestore batch write"
      pattern: "batch\\.set.*sessionRef"
    - from: "start() function"
      to: "state.sessionStartTime"
      via: "Date.now() captured when timer starts"
      pattern: "sessionStartTime.*Date\\.now"
---

<objective>
Add session-level data recording to every completed focus session, creating the data foundation that powers all future analytics and export features.

Purpose: DATA-01, DATA-02, DATA-03 -- granular session data in Firestore without breaking existing stats.
Output: `recordSessionData()` function called on every focus completion, writing session subcollection docs atomically with existing stats updates.
</objective>

<execution_context>
@/Users/user/.claude/agents/gsd-executor.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-foundation-and-projects/04-RESEARCH.md
@.planning/phases/03-payment-infrastructure-and-feature-gating/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend state object and add session recording function</name>
  <files>index.html</files>
  <action>
    1. Extend the `state` object (line ~2320) with four new fields:
       - `projects: []` -- array of `{ id, name, createdAt }` objects
       - `activeProjectId: null` -- currently selected project ID
       - `currentTaskId: null` -- tracks which task is being worked on (populated when timer starts)
       - `sessionStartTime: null` -- timestamp (ms) captured when timer starts, used for accurate startedAt in session records

    2. Add `projects` key to `STORAGE_KEYS` (line ~2182):
       ```
       projects: 'pomodoro-projects',
       ```

    3. Add `loadProjects()` and `saveProjects()` functions after the existing `saveTasks()` function (line ~2394):
       - `loadProjects()`: Read from localStorage, parse JSON into `state.projects`
       - `saveProjects()`: Write `state.projects` to localStorage as JSON

    4. Create `recordSessionData()` async function. Place it AFTER the existing `updateFirestoreOnComplete()` function (line ~3139). Implementation:
       - Guard: `if (!state.user || state.mode !== 'focus') return;`
       - Generate session ID: `const sessionId = crypto.randomUUID();`
       - Build session document path: `fbDb.collection('users').doc(uid).collection('sessions').doc(sessionId)`
       - Session data object:
         ```
         {
           startedAt: new Date(state.sessionStartTime || Date.now() - state.settings.focusDuration * 60 * 1000),
           duration: state.settings.focusDuration,
           projectId: state.activeProjectId || null,
           taskId: state.currentTaskId || null,
           hourOfDay: new Date().getHours(),
           dayOfWeek: new Date().getDay(),
           createdAt: firebase.firestore.FieldValue.serverTimestamp()
         }
         ```
       - CRITICAL: `startedAt` uses `state.sessionStartTime` (captured when timer starts in Task 2), NOT `serverTimestamp()`. The `serverTimestamp()` would record completion time, not start time. The fallback `Date.now() - duration * 60 * 1000` is a safety net if sessionStartTime is somehow null.
       - Use `fbDb.batch()` for atomic write:
         - `batch.set(sessionRef, sessionData)`
         - `batch.set(userRef, { ...existing stats update fields... }, { merge: true })`
       - Wrap in try/catch, console.error on failure, never throw (don't break user flow)

    IMPORTANT: The batch write in `recordSessionData()` should include the SAME aggregate stats logic currently in `updateFirestoreOnComplete()` (dailyCounts, dailyMinutes, totalSessions, totalMinutes, etc.). This means `recordSessionData()` REPLACES `updateFirestoreOnComplete()` -- it does everything that function does PLUS the session subcollection write, all in one atomic batch.

    However, note the existing `updateFirestoreOnComplete()` does a read-then-write pattern (reads current cloud data, then writes). The research recommends using `FieldValue.increment()` instead, which is atomic and avoids the read. Refactor to use `FieldValue.increment()` for dailyCounts, dailyMinutes, totalSessions, totalMinutes. Keep the `{ merge: true }` on the user doc set.

    The refactored approach:
    ```javascript
    const userUpdate = {
      [`dailyCounts.${today}`]: firebase.firestore.FieldValue.increment(1),
      [`dailyMinutes.${today}`]: firebase.firestore.FieldValue.increment(state.settings.focusDuration),
      totalSessions: firebase.firestore.FieldValue.increment(1),
      totalMinutes: firebase.firestore.FieldValue.increment(state.settings.focusDuration),
      displayName: state.user.displayName || '',
      photoURL: state.user.photoURL || '',
      updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
    };
    batch.set(userRef, userUpdate, { merge: true });
    ```

    Note: Using dot-notation keys like `dailyCounts.${today}` with `set({ merge: true })` updates only that nested field. This is equivalent to `update()` but works even if the document doesn't exist yet.
  </action>
  <verify>
    Search index.html for `recordSessionData` -- function must exist.
    Search for `state.projects` and `state.activeProjectId` and `state.currentTaskId` and `state.sessionStartTime` in state object.
    Search for `crypto.randomUUID` -- must be used for session IDs.
    Search for `batch.commit` -- must use batch writes.
    Search for `FieldValue.increment` -- must use atomic increments.
    Search for `STORAGE_KEYS` -- must include `projects` key.
    Verify `startedAt` does NOT use `serverTimestamp()` -- must use `state.sessionStartTime`.
  </verify>
  <done>
    `recordSessionData()` function exists with batch write (session subcollection + aggregate stats).
    `startedAt` field uses `state.sessionStartTime` (not serverTimestamp), accurately recording when the session began.
    State object extended with projects, activeProjectId, currentTaskId, sessionStartTime.
    STORAGE_KEYS includes projects.
    loadProjects/saveProjects functions exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire session recording into timer completion and add saveProjects to Firestore</name>
  <files>index.html, sw.js</files>
  <action>
    1. In the timer completion handler (line ~3303, inside `if (state.mode === 'focus')`):
       - Replace `updateFirestoreOnComplete().then(() => loadLeaderboard());` with:
         `recordSessionData().then(() => loadLeaderboard());`
       - This single call now handles both session recording AND aggregate stats atomically.
       - Remove or comment out the old `updateFirestoreOnComplete()` function since `recordSessionData()` replaces it.

    2. Add `saveProjectsToFirestore()` async function (near the other Firestore functions):
       - Writes `state.projects` array to the user document: `fbDb.collection('users').doc(uid).set({ projects: state.projects, updatedAt: serverTimestamp() }, { merge: true })`
       - Guard: `if (!state.user) return;`
       - Wrap in try/catch, silent fail

    3. Add `loadProjectsFromFirestore()` async function:
       - Reads user document, extracts `data.projects || []`
       - Sets `state.projects = data.projects || []`
       - Calls `saveProjects()` (localStorage) to cache locally
       - Guard: `if (!state.user) return;`

    4. Wire `loadProjectsFromFirestore()` into the auth state handler -- call it when user signs in, alongside the existing `pullStatsFromFirestore()` call. Find where `pullStatsFromFirestore()` is called after sign-in and add `loadProjectsFromFirestore()` nearby.

    5. Call `loadProjects()` in the `init()` function alongside existing `loadTasks()`, `loadSettings()`, `loadStats()` calls.

    6. Capture session start time and current task when timer starts: In the `start()` function, find where the timer begins. Before the timer interval starts, add BOTH:
       - `state.sessionStartTime = Date.now();` -- captures the actual moment the session begins (CRITICAL: this is used by recordSessionData() for the startedAt field, so the session record reflects when the user started focusing, not when the timer completed)
       - `state.currentTaskId = state.tasks.find(t => !t.completed)?.id || null;` -- captures which task the user is working on

    7. Bump `CACHE_NAME` in sw.js from `'pomodoro-v39'` to `'pomodoro-v40'`.
  </action>
  <verify>
    Search for `recordSessionData()` call in the timer completion section (should replace `updateFirestoreOnComplete`).
    Search for `saveProjectsToFirestore` and `loadProjectsFromFirestore` functions.
    Search for `loadProjects()` in init section.
    Search for `sessionStartTime.*Date.now` in start function -- must capture start time.
    Search for `currentTaskId` assignment in start function.
    Verify sw.js contains `pomodoro-v40`.
    Verify `updateFirestoreOnComplete` is removed or commented out.
  </verify>
  <done>
    Timer completion calls `recordSessionData()` instead of `updateFirestoreOnComplete()`.
    Session start time captured via `state.sessionStartTime = Date.now()` when timer starts.
    Projects sync to/from Firestore on auth state changes.
    Projects load from localStorage on init.
    currentTaskId set to first incomplete task when timer starts.
    Service worker cache version bumped.
    Existing daily stats still update correctly (via FieldValue.increment in batch).
  </done>
</task>

</tasks>

<verification>
1. `recordSessionData` function exists and uses `fbDb.batch()` with both session subcollection write and user aggregate update
2. Timer completion handler calls `recordSessionData()` (not `updateFirestoreOnComplete()`)
3. `startedAt` field in session data uses `state.sessionStartTime` (NOT `serverTimestamp()`) -- must record when timer started, not when it completed
4. `state.sessionStartTime = Date.now()` is set in the `start()` function before timer interval begins
5. `state` object has `projects: []`, `activeProjectId: null`, `currentTaskId: null`, `sessionStartTime: null`
6. `STORAGE_KEYS` includes `projects`
7. `loadProjects()`, `saveProjects()`, `saveProjectsToFirestore()`, `loadProjectsFromFirestore()` all exist
8. `FieldValue.increment` used for atomic counter updates (not read-modify-write)
9. sw.js `CACHE_NAME` is `'pomodoro-v40'`
</verification>

<success_criteria>
- Session recording function creates Firestore subcollection documents atomically with stats
- Session startedAt accurately reflects when the timer was started (not completion time)
- State extended for projects and active project tracking
- Projects persist in localStorage and sync to Firestore
- Existing daily stats continue to work (no breaking changes)
- No new UI added (data layer only)
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-foundation-and-projects/04-01-SUMMARY.md`
</output>

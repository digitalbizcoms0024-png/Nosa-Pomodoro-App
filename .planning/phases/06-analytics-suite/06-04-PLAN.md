---
phase: 06-analytics-suite
plan: 04
type: execute
wave: 4
depends_on: ["06-01", "06-03"]
files_modified: [index.html, sw.js, functions/src/index.ts, functions/src/aggregateUserStats.ts]
autonomous: false

must_haves:
  truths:
    - "Premium user can view a GitHub-style yearly heatmap showing daily focus intensity"
    - "Premium user can see annual summary stats (total hours, sessions, most productive day, longest streak)"
    - "Percentile ranking Cloud Function is ready to deploy (pre-computes daily user rankings)"
    - "Yearly tab handles first-year users with partial data gracefully"
  artifacts:
    - path: "index.html"
      provides: "Yearly tab with heatmap grid, annual summary stats, optional percentile display"
      contains: "renderYearlyTab"
    - path: "functions/src/aggregateUserStats.ts"
      provides: "Scheduled Cloud Function for daily percentile ranking aggregation"
      contains: "aggregateUserStats"
    - path: "functions/src/index.ts"
      provides: "Re-export of aggregateUserStats function"
      contains: "aggregateUserStats"
    - path: "sw.js"
      provides: "Updated cache version"
  key_links:
    - from: "renderAnalyticsTab('yearly')"
      to: "Yearly panel with heatmap + summary"
      via: "renderYearlyTab() fetches full year of sessions"
      pattern: "renderYearlyTab"
    - from: "Heatmap grid divs"
      to: "CSS color-mix() intensity"
      via: "intensity-N class mapping to color-mix(in srgb, var(--primary) N%, var(--ring-track))"
      pattern: "intensity-"
    - from: "aggregateUserStats Cloud Function"
      to: "userStats Firestore collection"
      via: "Scheduled daily, writes percentile ranking per user"
      pattern: "userStats"
---

<objective>
Yearly tab (heatmap + annual summary) and percentile ranking Cloud Function.

Purpose: The yearly report is the "wow" feature — a visual representation of an entire year of work that creates pride and retention. The heatmap (GitHub-style) makes consistency visible. The percentile ranking adds social motivation ("Better than 73% of users").
Output: Fully functional Yearly tab with heatmap and stats, plus deployable Cloud Function for percentile calculation.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-analytics-suite/06-RESEARCH.md
@.planning/phases/06-analytics-suite/06-01-SUMMARY.md
@.planning/phases/06-analytics-suite/06-02-SUMMARY.md
@.planning/phases/06-analytics-suite/06-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Yearly heatmap, annual summary stats, and percentile display</name>
  <files>index.html</files>
  <action>
  Add to the Analytics IIFE in index.html:

  **1. Yearly tab renderer:**
  GitHub-style heatmap (52-53 columns x 7 rows, each cell = one day). Uses CSS Grid. Color intensity via color-mix() with --primary and --ring-track. Hand-rolled (no library — only 365 divs per research recommendation).

  ```javascript
  async function renderYearlyTab() {
    const panel = analyticsDialog.querySelector('[data-tab-panel="yearly"]');
    panel.innerHTML = '<div class="analytics-loading">Loading yearly report...</div>';

    try {
      const now = new Date();
      const yearStart = new Date(now.getFullYear(), 0, 1);
      const sessions = await fetchSessions(yearStart, now);

      // Aggregate by date
      const dateMap = {};
      sessions.forEach(s => {
        const d = s.startedAt?.toDate ? s.startedAt.toDate() : new Date(s.startedAt);
        const key = d.toISOString().split('T')[0];
        dateMap[key] = (dateMap[key] || 0) + (s.duration || 0);
      });

      const maxMinutes = Math.max(1, ...Object.values(dateMap));

      // Annual summary stats
      const totalMinutes = sessions.reduce((s, x) => s + (x.duration || 0), 0);
      const totalSessions = sessions.length;
      const uniqueDays = new Set(Object.keys(dateMap)).size;

      // Most productive day of week
      const dayTotals = Array(7).fill(0);
      sessions.forEach(s => {
        const d = s.startedAt?.toDate ? s.startedAt.toDate() : new Date(s.startedAt);
        dayTotals[d.getDay()] += (s.duration || 0);
      });
      const bestDayIndex = dayTotals.indexOf(Math.max(...dayTotals));
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

      // Calculate longest streak
      const sortedDates = Object.keys(dateMap).sort();
      let longestStreak = 0, currentStreak = 0;
      for (let i = 0; i < sortedDates.length; i++) {
        if (i === 0) { currentStreak = 1; }
        else {
          const prev = new Date(sortedDates[i - 1] + 'T00:00:00');
          const curr = new Date(sortedDates[i] + 'T00:00:00');
          const diffDays = Math.round((curr - prev) / (24 * 60 * 60 * 1000));
          currentStreak = diffDays === 1 ? currentStreak + 1 : 1;
        }
        longestStreak = Math.max(longestStreak, currentStreak);
      }

      // Build heatmap HTML
      // GitHub style: columns = weeks, rows = days (Sun=0 at top)
      const firstDay = new Date(now.getFullYear(), 0, 1);
      const startOffset = firstDay.getDay(); // 0=Sun

      let heatmapHTML = '<div class="heatmap-labels">';
      ['', 'Mon', '', 'Wed', '', 'Fri', ''].forEach(label => {
        heatmapHTML += `<div class="heatmap-label">${label}</div>`;
      });
      heatmapHTML += '</div><div class="heatmap-grid">';

      // Calculate number of weeks
      const lastDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const totalDays = Math.ceil((lastDay - firstDay) / (24 * 60 * 60 * 1000)) + 1;
      const totalWeeks = Math.ceil((totalDays + startOffset) / 7);

      for (let week = 0; week < totalWeeks; week++) {
        heatmapHTML += '<div class="heatmap-week">';
        for (let day = 0; day < 7; day++) {
          const dayIndex = week * 7 + day - startOffset;
          const date = new Date(firstDay);
          date.setDate(date.getDate() + dayIndex);

          if (dayIndex < 0 || date > lastDay || date.getFullYear() !== now.getFullYear()) {
            heatmapHTML += '<div class="heatmap-day empty"></div>';
            continue;
          }

          const dateStr = date.toISOString().split('T')[0];
          const minutes = dateMap[dateStr] || 0;
          const intensity = minutes === 0 ? 0 : Math.min(4, Math.ceil((minutes / maxMinutes) * 4));

          const tooltip = `${date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}: ${minutes} min`;
          heatmapHTML += `<div class="heatmap-day intensity-${intensity}" title="${tooltip}"></div>`;
        }
        heatmapHTML += '</div>';
      }
      heatmapHTML += '</div>';

      // Month labels below heatmap
      let monthLabelsHTML = '<div class="heatmap-months">';
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      for (let m = 0; m <= now.getMonth(); m++) {
        const monthStart = new Date(now.getFullYear(), m, 1);
        const daysSinceStart = Math.floor((monthStart - firstDay) / (24 * 60 * 60 * 1000));
        const weekOfMonth = Math.floor((daysSinceStart + startOffset) / 7);
        monthLabelsHTML += `<span class="heatmap-month" style="grid-column: ${weekOfMonth + 2}">${months[m]}</span>`;
      }
      monthLabelsHTML += '</div>';

      // Optional percentile display (reads from userStats collection if available)
      let percentileHTML = '';
      if (state.user) {
        try {
          const statsDoc = await fbDb.collection('userStats').doc(state.user.uid).get();
          if (statsDoc.exists && statsDoc.data().percentile != null) {
            const pct = statsDoc.data().percentile;
            percentileHTML = `<div class="percentile-card"><span class="percentile-value">Top ${100 - pct}%</span><span class="percentile-label">Better than ${pct}% of users</span></div>`;
          }
        } catch (e) {
          // userStats collection may not exist yet — that's fine, skip percentile
        }
      }

      panel.innerHTML = `
        <h3 class="analytics-section-title">${now.getFullYear()} Productivity Report</h3>
        <div class="annual-stats">
          <div class="annual-stat"><div class="annual-stat-value">${Math.round(totalMinutes / 60 * 10) / 10}</div><div class="annual-stat-label">Hours focused</div></div>
          <div class="annual-stat"><div class="annual-stat-value">${totalSessions}</div><div class="annual-stat-label">Sessions</div></div>
          <div class="annual-stat"><div class="annual-stat-value">${uniqueDays}</div><div class="annual-stat-label">Active days</div></div>
          <div class="annual-stat"><div class="annual-stat-value">${longestStreak}</div><div class="annual-stat-label">Longest streak</div></div>
        </div>
        <p class="annual-insight">Most productive day: <strong>${dayNames[bestDayIndex]}</strong></p>
        ${percentileHTML}
        <h3 class="analytics-section-title" style="margin-top:20px;">Daily Activity</h3>
        <div class="heatmap-container">
          ${heatmapHTML}
          ${monthLabelsHTML}
        </div>
        <div class="heatmap-legend">
          <span class="heatmap-legend-label">Less</span>
          <div class="heatmap-day intensity-0"></div>
          <div class="heatmap-day intensity-1"></div>
          <div class="heatmap-day intensity-2"></div>
          <div class="heatmap-day intensity-3"></div>
          <div class="heatmap-day intensity-4"></div>
          <span class="heatmap-legend-label">More</span>
        </div>
      `;

    } catch (err) {
      console.error('Analytics yearly error:', err);
      panel.innerHTML = '<p class="analytics-loading">Unable to load yearly report.</p>';
    }
  }
  ```

  **2. Update renderAnalyticsTab switch:** Add `case 'yearly': return renderYearlyTab();`

  **3. Heatmap CSS:**
  ```css
  .heatmap-container { overflow-x: auto; padding-bottom: 8px; }
  .heatmap-grid { display: flex; gap: 3px; }
  .heatmap-labels { display: flex; flex-direction: column; gap: 3px; margin-right: 4px; float: left; }
  .heatmap-label { height: 13px; font-size: 9px; color: var(--text-secondary); line-height: 13px; }
  .heatmap-week { display: flex; flex-direction: column; gap: 3px; }
  .heatmap-day { width: 13px; height: 13px; border-radius: 2px; background: var(--ring-track); }
  .heatmap-day.empty { background: transparent; }
  .heatmap-day.intensity-1 { background: color-mix(in srgb, var(--primary) 25%, var(--ring-track)); }
  .heatmap-day.intensity-2 { background: color-mix(in srgb, var(--primary) 50%, var(--ring-track)); }
  .heatmap-day.intensity-3 { background: color-mix(in srgb, var(--primary) 75%, var(--ring-track)); }
  .heatmap-day.intensity-4 { background: var(--primary); }
  .heatmap-months { display: grid; grid-template-columns: repeat(53, 13px); gap: 3px; margin-left: 22px; margin-top: 4px; }
  .heatmap-month { font-size: 9px; color: var(--text-secondary); white-space: nowrap; }
  .heatmap-legend { display: flex; align-items: center; gap: 3px; justify-content: flex-end; margin-top: 8px; }
  .heatmap-legend .heatmap-day { cursor: default; }
  .heatmap-legend-label { font-size: 9px; color: var(--text-secondary); margin: 0 2px; }

  .annual-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 16px; }
  .annual-stat { text-align: center; padding: 10px 4px; background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-sm); }
  .annual-stat-value { font-size: 1.4rem; font-weight: 700; color: var(--text); }
  .annual-stat-label { font-size: 0.7rem; color: var(--text-secondary); margin-top: 2px; }
  .annual-insight { font-size: 0.85rem; color: var(--text-secondary); text-align: center; margin-bottom: 12px; }
  .annual-insight strong { color: var(--primary); }

  .percentile-card { text-align: center; background: var(--primary); color: #fff; padding: 12px; border-radius: var(--radius-sm); margin-bottom: 16px; }
  .percentile-value { font-size: 1.2rem; font-weight: 700; display: block; }
  .percentile-label { font-size: 0.8rem; opacity: 0.9; }

  @media (max-width: 480px) {
    .annual-stats { grid-template-columns: repeat(2, 1fr); }
    .heatmap-day { width: 10px; height: 10px; }
    .heatmap-label { height: 10px; font-size: 8px; line-height: 10px; }
    .heatmap-grid { gap: 2px; }
    .heatmap-week { gap: 2px; }
    .heatmap-months { grid-template-columns: repeat(53, 10px); gap: 2px; }
  }
  ```
  </action>
  <verify>
  1. Open Analytics, click Yearly tab
  2. Annual stats show (hours, sessions, active days, longest streak)
  3. "Most productive day" text shows correct day name
  4. GitHub-style heatmap renders with correct date grid for current year
  5. Heatmap cells show intensity colors (hover for tooltip with date + minutes)
  6. Legend shows Less → More gradient
  7. Month labels align with correct weeks
  8. Empty days at start/end of year render as transparent
  9. Heatmap is horizontally scrollable on mobile
  10. Theme-aware: heatmap uses --primary and --ring-track for coloring
  11. If userStats doc exists (after Cloud Function runs), percentile card shows
  12. If no sessions this year, shows zeros gracefully
  </verify>
  <done>Yearly tab renders GitHub-style heatmap with intensity coloring, annual summary stats (hours, sessions, active days, streak), most productive day, and optional percentile ranking card</done>
</task>

<task type="auto">
  <name>Task 2: Percentile ranking Cloud Function and sw.js bump</name>
  <files>functions/src/aggregateUserStats.ts, functions/src/index.ts, sw.js</files>
  <action>
  **1. Create `functions/src/aggregateUserStats.ts`:**
  A scheduled Cloud Function that runs daily at 3am UTC. Fetches all users' weekly session totals, calculates percentile ranking, and writes to a `userStats` collection.

  ```typescript
  import { onSchedule } from 'firebase-functions/v2/scheduler';
  import { getFirestore, FieldValue } from 'firebase-admin/firestore';

  export const aggregateUserStats = onSchedule({
    schedule: 'every day 03:00',
    timeZone: 'UTC',
    region: 'us-central1',
    timeoutSeconds: 300,
    memory: '256MiB',
  }, async () => {
    const db = getFirestore();
    const usersSnapshot = await db.collection('users').get();

    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);

    // Calculate weekly totals for all users
    const scores: { uid: string; totalMinutes: number }[] = [];

    for (const userDoc of usersSnapshot.docs) {
      const uid = userDoc.id;
      const sessionsSnapshot = await db
        .collection('users').doc(uid).collection('sessions')
        .where('startedAt', '>=', weekAgo)
        .get();

      const totalMinutes = sessionsSnapshot.docs.reduce(
        (sum, doc) => sum + (doc.data().duration || 0), 0
      );

      // Only include users with at least 1 session
      if (totalMinutes > 0) {
        scores.push({ uid, totalMinutes });
      }
    }

    if (scores.length === 0) {
      console.log('No active users this week');
      return;
    }

    // Sort descending by total minutes
    scores.sort((a, b) => b.totalMinutes - a.totalMinutes);

    // Write percentiles in batches (Firestore batch limit = 500)
    const batchSize = 450;
    for (let i = 0; i < scores.length; i += batchSize) {
      const batch = db.batch();
      const chunk = scores.slice(i, i + batchSize);

      chunk.forEach((entry, chunkIndex) => {
        const globalIndex = i + chunkIndex;
        const percentile = Math.round((1 - globalIndex / scores.length) * 100);
        const ref = db.collection('userStats').doc(entry.uid);

        batch.set(ref, {
          weeklyMinutes: entry.totalMinutes,
          percentile: percentile,
          rank: globalIndex + 1,
          totalUsers: scores.length,
          updatedAt: FieldValue.serverTimestamp()
        }, { merge: true });
      });

      await batch.commit();
    }

    console.log(`Updated stats for ${scores.length} active users`);
  });
  ```

  **2. Update `functions/src/index.ts`:**
  Add re-export:
  ```typescript
  export { aggregateUserStats } from './aggregateUserStats.js';
  ```

  **3. Bump sw.js cache version** (increment by 1).
  </action>
  <verify>
  1. `functions/src/aggregateUserStats.ts` exists with onSchedule function
  2. `functions/src/index.ts` exports aggregateUserStats
  3. TypeScript compilation check: `cd functions && npx tsc --noEmit` (or just verify no syntax errors)
  4. sw.js cache version bumped
  </verify>
  <done>Percentile ranking Cloud Function created (scheduled daily, writes to userStats collection), index.ts re-exports it, sw.js cache bumped</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Analytics Suite: 4-tab dialog (Overview with productivity gauge + weekly summary + focus hours, Projects with donut + trends, Forecast with day-of-week predictions, Yearly with heatmap + annual stats). All premium-gated. Chart.js integration with theme-aware colors. Cloud Function for percentile ranking.</what-built>
  <how-to-verify>
  1. Open app in browser, click the Analytics toolbar button (bar chart icon)
  2. If not premium, verify upgrade prompt appears
  3. With premium access, verify Analytics dialog opens on Overview tab:
     - Circular productivity gauge with score, label, and week comparison
     - Weekly summary with 3 stat cards showing comparisons
     - Best focus hours 24-hour bar chart with peak highlighted and recommendation text
  4. Click Projects tab:
     - Donut chart shows time per project
     - Weekly trend line chart below
  5. Click Forecast tab:
     - Bar chart showing predicted minutes per day
     - Confidence badge (high/medium/low)
     - Day-by-day detail list with today highlighted
  6. Click Yearly tab:
     - Annual stats (hours, sessions, active days, streak)
     - GitHub-style heatmap with color intensity
     - Month labels, day labels, legend
  7. Switch themes and reopen — charts use new theme colors
  8. Close dialog via X, Escape, and backdrop click
  9. Verify on mobile-width viewport — responsive layout
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. ANLY-01: Projects tab shows time per project (donut) + trends (line chart)
2. ANLY-02: Overview tab shows best focus hours (bar chart + recommendation text)
3. ANLY-03: Overview tab shows productivity score 0-100 (gauge with color + label)
4. ANLY-04: Overview tab shows weekly summary (vs last week + 4-week avg)
5. ANLY-05: Forecast tab shows day-of-week predictions with confidence
6. ANLY-06: Yearly tab shows heatmap + annual summary
7. All analytics premium-gated
8. Chart.js loaded, theme colors applied to all charts
9. Cloud Function for percentile ranking created and ready to deploy
10. No memory leaks (chart instances destroyed before recreation)
</verification>

<success_criteria>
- Yearly heatmap: GitHub-style grid showing daily focus intensity with color-mix() CSS
- Annual stats: hours, sessions, active days, longest streak displayed in 4-card grid
- Most productive day identified and displayed
- Heatmap responsive on mobile (smaller cells, scrollable)
- Percentile card conditionally shown (only if userStats doc exists)
- Cloud Function: scheduled daily, calculates percentile ranking, writes to userStats collection
- functions/src/index.ts re-exports aggregateUserStats
- sw.js cache version bumped
- Human verification of complete analytics suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/06-analytics-suite/06-04-SUMMARY.md`
</output>

---
phase: 03-payment-infrastructure-and-feature-gating
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - functions/src/stripe/checkout.ts
  - functions/src/stripe/portal.ts
  - functions/src/stripe/verify-subscription.ts
  - functions/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Authenticated user can create a Stripe Checkout session for any of the 3 pricing tiers and receive a redirect URL"
    - "Monthly and yearly checkouts include a 7-day free trial; lifetime checkout charges immediately"
    - "Authenticated user with an active subscription can create a Customer Portal session to manage billing"
    - "Server-side subscription verification returns correct access status for all subscription states"
    - "Unauthenticated requests to any function are rejected with an error"
  artifacts:
    - path: "functions/src/stripe/checkout.ts"
      provides: "Checkout session creation for 3 pricing tiers"
      contains: "createCheckoutSession"
    - path: "functions/src/stripe/portal.ts"
      provides: "Customer Portal session creation"
      contains: "createPortalSession"
    - path: "functions/src/stripe/verify-subscription.ts"
      provides: "Server-side subscription status verification"
      contains: "verifySubscription"
    - path: "functions/src/index.ts"
      provides: "All Cloud Functions exported"
      contains: "createCheckoutSession"
  key_links:
    - from: "functions/src/stripe/checkout.ts"
      to: "Stripe Checkout API"
      via: "stripe.checkout.sessions.create()"
      pattern: "checkout\\.sessions\\.create"
    - from: "functions/src/stripe/portal.ts"
      to: "Firestore users/{uid}/subscription"
      via: "Read customerId from Firestore before creating portal session"
      pattern: "customerId"
    - from: "functions/src/stripe/verify-subscription.ts"
      to: "Firestore users/{uid}/subscription"
      via: "Read subscription doc and check status against PREMIUM_STATUSES"
      pattern: "PREMIUM_STATUSES"
---

<objective>
Implement the three callable Cloud Functions that power the client-side payment flow: checkout session creation, customer portal access, and subscription verification.

Purpose: These are the API endpoints the frontend will call. Without them, users cannot initiate checkout, manage subscriptions, or have their premium status verified server-side.

Output: Three `onCall` Cloud Functions (createCheckoutSession, createPortalSession, verifySubscription) exported from index.ts, all requiring authentication.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-payment-infrastructure-and-feature-gating/03-RESEARCH.md
@.planning/phases/03-payment-infrastructure-and-feature-gating/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement checkout session and portal session Cloud Functions</name>
  <files>
    functions/src/stripe/checkout.ts
    functions/src/stripe/portal.ts
    functions/src/index.ts
  </files>
  <action>
    **functions/src/stripe/checkout.ts:**

    Import `onCall` from `firebase-functions/v2/https`, `HttpsError` from same. Import `getStripe`, `getDb` from utils.

    Export `createCheckoutSession` as an `onCall` function:

    1. Guard: if `!request.auth` throw `HttpsError('unauthenticated', 'Must be signed in')`
    2. Extract `{ priceId, mode }` from `request.data`
       - Validate `mode` is either `'subscription'` or `'payment'`
       - Validate `priceId` is a non-empty string starting with `'price_'`
       - Throw `HttpsError('invalid-argument', ...)` if validation fails
    3. Build checkout session config:
       - `mode`: from request data
       - `line_items`: `[{ price: priceId, quantity: 1 }]`
       - `success_url`: `'https://pomodorotimer.vip/?checkout=success&session_id={CHECKOUT_SESSION_ID}'`
       - `cancel_url`: `'https://pomodorotimer.vip/?checkout=canceled'`
       - `customer_email`: `request.auth.token.email`
       - `client_reference_id`: `request.auth.uid` (used by webhook to link to Firebase user)
       - If `mode === 'subscription'`: add `subscription_data: { trial_period_days: 7, metadata: { firebaseUid: request.auth.uid } }`
       - If `mode === 'payment'` (lifetime): add `payment_intent_data: { metadata: { firebaseUid: request.auth.uid } }` — NO trial for lifetime
    4. Call `stripe.checkout.sessions.create(sessionConfig)`
    5. Return `{ url: session.url }`

    **functions/src/stripe/portal.ts:**

    Import `onCall`, `HttpsError` from `firebase-functions/v2/https`. Import `getStripe`, `getDb` from utils.

    Export `createPortalSession` as an `onCall` function:

    1. Guard: if `!request.auth` throw `HttpsError('unauthenticated', ...)`
    2. Read `users/{uid}/subscription` doc from Firestore
    3. Extract `customerId` from doc data
    4. If no `customerId`: throw `HttpsError('failed-precondition', 'No active subscription found')`
    5. Call `stripe.billingPortal.sessions.create({ customer: customerId, return_url: 'https://pomodorotimer.vip/' })`
    6. Return `{ url: session.url }`

    **functions/src/index.ts:**
    - Add re-exports for `createCheckoutSession` from `./stripe/checkout`
    - Add re-export for `createPortalSession` from `./stripe/portal`
    - Keep existing `stripeWebhook` export from Plan 01

    Run `cd functions && npx tsc --noEmit` to verify compilation.
  </action>
  <verify>
    1. `cd functions && npx tsc --noEmit` — compiles without errors
    2. `grep 'checkout.sessions.create' functions/src/stripe/checkout.ts` — Stripe API call present
    3. `grep 'trial_period_days' functions/src/stripe/checkout.ts` — trial config present
    4. `grep 'billingPortal.sessions.create' functions/src/stripe/portal.ts` — portal API call present
    5. `grep 'client_reference_id' functions/src/stripe/checkout.ts` — Firebase UID linkage present
    6. `grep 'createCheckoutSession' functions/src/index.ts` — exported from index
    7. `grep 'createPortalSession' functions/src/index.ts` — exported from index
  </verify>
  <done>
    Checkout function creates sessions for subscription (with 7-day trial) and payment (lifetime, no trial) modes with proper validation. Portal function reads customerId from Firestore and creates portal session. Both reject unauthenticated requests. Both exported from index.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement server-side subscription verification function</name>
  <files>
    functions/src/stripe/verify-subscription.ts
    functions/src/index.ts
  </files>
  <action>
    **functions/src/stripe/verify-subscription.ts:**

    Import `onCall`, `HttpsError` from `firebase-functions/v2/https`. Import `getDb`, `PREMIUM_STATUSES` from utils.

    Export `verifySubscription` as an `onCall` function:

    1. Guard: if `!request.auth` throw `HttpsError('unauthenticated', ...)`
    2. Read `users/{request.auth.uid}/subscription` doc from Firestore
    3. If doc doesn't exist or has no data: return `{ hasAccess: false, status: 'none', tier: null }`
    4. Extract subscription data from doc
    5. Determine access: `hasAccess = PREMIUM_STATUSES.includes(subscription.status)`
    6. Determine tier from status/priceId:
       - If `status === 'lifetime'`: tier is `'lifetime'`
       - Else: tier is derived from `priceId` (will be matched client-side to plan name)
    7. Return:
       ```
       {
         hasAccess: boolean,
         status: subscription.status,
         tier: 'monthly' | 'yearly' | 'lifetime' | null,
         gracePeriod: subscription.status === 'past_due',
         currentPeriodEnd: subscription.currentPeriodEnd || null,
         cancelAtPeriodEnd: subscription.cancelAtPeriodEnd || false
       }
       ```

    **functions/src/index.ts:**
    - Add re-export for `verifySubscription` from `./stripe/verify-subscription`

    Run `cd functions && npx tsc --noEmit` to verify full project compiles.
    Run `cd functions && npx tsc` to produce the compiled lib/ output.
  </action>
  <verify>
    1. `cd functions && npx tsc` — full build succeeds, lib/ directory created
    2. `grep 'PREMIUM_STATUSES' functions/src/stripe/verify-subscription.ts` — uses shared constants
    3. `grep 'hasAccess' functions/src/stripe/verify-subscription.ts` — returns access boolean
    4. `grep 'gracePeriod' functions/src/stripe/verify-subscription.ts` — handles past_due grace period
    5. `grep 'verifySubscription' functions/src/index.ts` — exported from index
    6. `ls functions/lib/index.js` — compiled output exists
  </verify>
  <done>
    Verification function reads Firestore subscription document, checks status against PREMIUM_STATUSES (active, trialing, past_due, lifetime), returns structured response with access boolean, tier info, grace period flag, and subscription metadata. Full functions/ project compiles to lib/.
  </done>
</task>

</tasks>

<verification>
1. `cd functions && npx tsc` — full project compiles without errors
2. `ls functions/lib/` — compiled JS files exist for all modules
3. All 4 Cloud Functions exported from index.ts: stripeWebhook, createCheckoutSession, createPortalSession, verifySubscription
4. Checkout handles both subscription (with trial) and payment (lifetime, no trial) modes
5. Portal reads customerId from Firestore (stored by webhook in Plan 01)
6. Verification uses PREMIUM_STATUSES constant shared with webhook handler
7. All onCall functions reject unauthenticated requests
</verification>

<success_criteria>
- Three new Cloud Functions (createCheckoutSession, createPortalSession, verifySubscription) compile and export correctly
- Checkout supports 3 tiers: monthly subscription, yearly subscription, lifetime payment
- 7-day trial applied only to subscription mode (not lifetime)
- Portal requires existing customerId in Firestore
- Verification returns structured access response for all subscription states
- Full TypeScript build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-payment-infrastructure-and-feature-gating/03-02-SUMMARY.md`
</output>

---
phase: 03-payment-infrastructure-and-feature-gating
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - functions/package.json
  - functions/tsconfig.json
  - functions/.env.yaml
  - functions/src/index.ts
  - functions/src/stripe/webhooks.ts
  - functions/src/utils/stripe-helpers.ts
  - firebase.json
  - .firebaserc
  - .gitignore
autonomous: true
user_setup:
  - service: firebase
    why: "Cloud Functions require Blaze (pay-as-you-go) billing plan"
    dashboard_config:
      - task: "Upgrade Firebase project to Blaze plan"
        location: "Firebase Console -> Project Settings -> Usage and billing -> Modify plan -> Blaze"
  - service: stripe
    why: "Payment processing — API keys and webhook secrets needed"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key (use test key sk_test_... during development)"
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint -> Signing secret (whsec_...)"
    dashboard_config:
      - task: "Create Stripe account if not already done"
        location: "https://dashboard.stripe.com/register"
      - task: "Create 3 products with prices in test mode: Monthly ($2/mo recurring), Yearly ($15/yr recurring), Lifetime ($47 one-time)"
        location: "Stripe Dashboard -> Product catalog -> Add product (create 3 products, each with 1 price)"
      - task: "Configure Customer Portal (allow cancel, plan change, payment method update)"
        location: "Stripe Dashboard -> Settings -> Billing -> Customer portal"
      - task: "Add webhook endpoint pointing to deployed Cloud Function URL (after deployment)"
        location: "Stripe Dashboard -> Developers -> Webhooks -> Add endpoint"

must_haves:
  truths:
    - "Firebase Cloud Functions project initializes and deploys without errors"
    - "Stripe webhook endpoint receives events and verifies signatures correctly"
    - "Webhook events sync subscription status to Firestore at users/{uid}/subscription"
    - "Duplicate webhook events are handled idempotently (no double-processing)"
    - "Lifetime purchases stored with status 'lifetime', subscriptions with Stripe status"
  artifacts:
    - path: "functions/package.json"
      provides: "Node.js project with stripe, firebase-admin, firebase-functions dependencies"
      contains: "stripe"
    - path: "functions/src/stripe/webhooks.ts"
      provides: "Webhook handler with signature verification and event processing"
      contains: "constructEvent"
    - path: "functions/src/index.ts"
      provides: "Cloud Functions entry point exporting all functions"
      contains: "export"
    - path: "firebase.json"
      provides: "Firebase project configuration for Cloud Functions"
      contains: "functions"
  key_links:
    - from: "functions/src/stripe/webhooks.ts"
      to: "Firestore users/{uid}/subscription"
      via: "firebase-admin Firestore write on webhook event"
      pattern: "db\\.doc.*users.*subscription"
    - from: "functions/src/stripe/webhooks.ts"
      to: "Stripe API"
      via: "stripe.webhooks.constructEvent for signature verification"
      pattern: "constructEvent"
---

<objective>
Set up the Firebase Cloud Functions v2 project and implement the Stripe webhook handler with idempotent event processing and Firestore subscription sync.

Purpose: This is the absolute foundation — without a working webhook endpoint that syncs subscription status to Firestore, no payment flow can function. Everything in Phase 3 depends on this.

Output: A deployable `functions/` directory with a working Stripe webhook handler that processes checkout completions, subscription updates/deletions, and payment failures, syncing status to `users/{uid}/subscription` in Firestore.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-payment-infrastructure-and-feature-gating/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Firebase Cloud Functions v2 project with TypeScript</name>
  <files>
    functions/package.json
    functions/tsconfig.json
    functions/src/index.ts
    functions/src/utils/stripe-helpers.ts
    functions/.env.yaml
    firebase.json
    .firebaserc
    .gitignore
  </files>
  <action>
    Create the `functions/` directory structure for Firebase Cloud Functions v2 with TypeScript.

    **functions/package.json:**
    - name: "pomodoro-functions"
    - Node.js engine: "22" (per project decision)
    - Dependencies: `stripe` (^17.x), `firebase-admin` (^12.x), `firebase-functions` (^6.x)
    - DevDependencies: `typescript` (^5.x), `@types/node`
    - Scripts: `build` (tsc), `serve` (firebase emulators:start), `deploy` (firebase deploy --only functions)
    - Set `"main": "lib/index.js"` (compiled output)

    **functions/tsconfig.json:**
    - Target: ES2022
    - Module: NodeNext / moduleResolution: NodeNext
    - outDir: "./lib"
    - rootDir: "./src"
    - strict: true
    - esModuleInterop: true

    **functions/src/utils/stripe-helpers.ts:**
    - Export a function `getStripe()` that lazily initializes Stripe client with `process.env.STRIPE_SECRET_KEY`
    - Export a function `getDb()` that lazily initializes Firestore via `getFirestore()` from firebase-admin
    - Export `initializeApp()` call from firebase-admin (call at top level)
    - Export constants for premium statuses: `PREMIUM_STATUSES = ['active', 'trialing', 'past_due', 'lifetime']`

    **functions/.env.yaml:**
    - Create with placeholder values:
      ```
      STRIPE_SECRET_KEY: "sk_test_REPLACE_ME"
      STRIPE_WEBHOOK_SECRET: "whsec_REPLACE_ME"
      ```

    **firebase.json:**
    - Check if file exists first. If it does, merge in the `functions` config.
    - If not, create with: `{ "functions": [{ "source": "functions", "codebase": "default", "ignore": ["node_modules", ".git"] }] }`

    **.firebaserc:**
    - Check if file exists. If not, create with project ID `pomodoro-timer-82980` (from existing Firebase config in index.html).

    **.gitignore:**
    - Append (don't overwrite) entries for: `functions/lib/`, `functions/node_modules/`, `functions/.env.yaml`

    Run `cd functions && npm install` to install dependencies.
    Run `cd functions && npx tsc --noEmit` to verify TypeScript compiles.
  </action>
  <verify>
    1. `ls functions/package.json functions/tsconfig.json functions/src/index.ts functions/src/utils/stripe-helpers.ts` — all exist
    2. `cd functions && npx tsc --noEmit` — exits 0 (no type errors)
    3. `cat functions/package.json | grep stripe` — stripe dependency present
    4. `cat firebase.json | grep functions` — functions config present
  </verify>
  <done>
    functions/ directory exists with valid TypeScript project, all dependencies installed, compiles without errors. firebase.json configured for Cloud Functions deployment.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Stripe webhook handler with idempotent event processing</name>
  <files>
    functions/src/stripe/webhooks.ts
    functions/src/index.ts
  </files>
  <action>
    Create the core webhook handler following the pattern from research, with these specific behaviors:

    **functions/src/stripe/webhooks.ts:**

    Import `onRequest` from `firebase-functions/v2/https`. Import Stripe, getDb, getStripe from utils.

    Export `stripeWebhook` as an `onRequest` function with config:
    - `cors: false` (Stripe webhooks are server-to-server, no CORS needed)
    - `timeoutSeconds: 60`
    - `memory: '256MiB'`

    **Request handling:**
    1. Only accept POST requests (return 405 for others)
    2. Extract `stripe-signature` header
    3. Use `stripe.webhooks.constructEvent(req.rawBody, sig, process.env.STRIPE_WEBHOOK_SECRET)` for signature verification
    4. On signature failure: return 400

    **Idempotency:**
    5. Check `stripe_events/{event.id}` document in Firestore
    6. If exists: return 200 'Already processed'
    7. If not: create document with `{ processed: true, type: event.type, createdAt: ISO string }`

    **Event handling — implement `processWebhookEvent(event)` switch:**

    `checkout.session.completed`:
    - Get `uid` from `session.client_reference_id` (set during checkout creation)
    - If `session.mode === 'subscription'`: retrieve full subscription via `stripe.subscriptions.retrieve(session.subscription)`, store to `users/{uid}/subscription` with merge: `{ subscriptionId, status, priceId, currentPeriodEnd, cancelAtPeriodEnd, customerId: session.customer, updatedAt }`
    - If `session.mode === 'payment'` (lifetime): store `{ status: 'lifetime', paymentIntentId: session.payment_intent, customerId: session.customer, updatedAt }`

    `customer.subscription.updated`:
    - Get `uid` from `subscription.metadata.firebaseUid`
    - Merge write: `{ status, priceId, currentPeriodEnd, cancelAtPeriodEnd, updatedAt }`

    `customer.subscription.deleted`:
    - Get `uid` from `subscription.metadata.firebaseUid`
    - Merge write: `{ status: 'canceled', canceledAt, updatedAt }`

    `invoice.payment_failed`:
    - Retrieve subscription from invoice.subscription
    - Get `uid` from `subscription.metadata.firebaseUid`
    - Merge write: `{ status: subscription.status (will be 'past_due'), lastPaymentError: ISO timestamp, updatedAt }`

    For all event types: if `uid` is missing, log error and return (don't crash).

    **Return 200 to Stripe immediately after signature verification and idempotency check.** Process event asynchronously after response (but within the same function execution since Cloud Functions wait for async completion).

    **functions/src/index.ts:**
    - Re-export `stripeWebhook` from `./stripe/webhooks`
    - This is the entry point Firebase uses to discover functions

    Run `cd functions && npx tsc --noEmit` to verify compilation.
  </action>
  <verify>
    1. `cd functions && npx tsc --noEmit` — compiles without errors
    2. `grep -c 'constructEvent' functions/src/stripe/webhooks.ts` — signature verification present
    3. `grep -c 'stripe_events' functions/src/stripe/webhooks.ts` — idempotency check present
    4. `grep 'checkout.session.completed' functions/src/stripe/webhooks.ts` — checkout handler present
    5. `grep 'customer.subscription' functions/src/stripe/webhooks.ts` — subscription lifecycle handlers present
    6. `grep 'invoice.payment_failed' functions/src/stripe/webhooks.ts` — payment failure handler present
    7. `grep 'lifetime' functions/src/stripe/webhooks.ts` — lifetime payment handling present
  </verify>
  <done>
    Webhook handler compiles, handles all 4 critical event types (checkout.session.completed, customer.subscription.updated, customer.subscription.deleted, invoice.payment_failed), verifies signatures with req.rawBody, deduplicates via Firestore event log, stores customerId for Portal access, and differentiates lifetime vs subscription payments.
  </done>
</task>

</tasks>

<verification>
1. `cd functions && npx tsc` — full build produces `lib/` directory with compiled JS
2. All webhook event types handled: checkout.session.completed, customer.subscription.updated, customer.subscription.deleted, invoice.payment_failed
3. Signature verification uses `req.rawBody` (not `req.body`)
4. Idempotency check prevents duplicate event processing
5. Lifetime payments stored with `status: 'lifetime'`
6. `customerId` stored during checkout for Portal access in Plan 02
7. firebase.json includes functions configuration
</verification>

<success_criteria>
- `functions/` directory exists with complete TypeScript project
- `npm install` has been run (node_modules present)
- `npx tsc` compiles without errors
- Webhook handler covers all subscription lifecycle events
- Idempotency mechanism prevents duplicate processing
- firebase.json configured for Cloud Functions deployment
</success_criteria>

<output>
After completion, create `.planning/phases/03-payment-infrastructure-and-feature-gating/03-01-SUMMARY.md`
</output>

---
phase: 01-audio-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [sw.js, index.html]
autonomous: false

must_haves:
  truths:
    - "User can play background audio by clicking a play button"
    - "User can pause background audio by clicking the same button"
    - "YouTube player is visible on screen at 200x200px minimum"
    - "Audio continues playing while focus timer runs"
    - "Player does not appear until user enables audio"
  artifacts:
    - path: "sw.js"
      provides: "YouTube domain exclusion from cache"
      contains: "youtube.com"
    - path: "index.html"
      provides: "YouTube player container, CSS styles, JS integration"
      contains: "youtube-player-container"
  key_links:
    - from: "play/pause button click handler"
      to: "YouTube player.playVideo() / pauseVideo()"
      via: "toggleAudio() function"
      pattern: "toggleAudio|playVideo|pauseVideo"
    - from: "window.onYouTubeIframeAPIReady"
      to: "YT.Player constructor"
      via: "global callback bridge"
      pattern: "onYouTubeIframeAPIReady"
    - from: "state.audio"
      to: "YouTube player state"
      via: "onPlayerStateChange callback"
      pattern: "state\\.audio\\.playing"
---

<objective>
Add YouTube-based background audio playback to the pomodoro timer with a visible, ToS-compliant player and play/pause controls.

Purpose: Users can listen to background music (Lofi Girl stream) while working, improving focus during pomodoro sessions. This is the foundation that Phase 2 and 3 build on.
Output: Working play/pause audio with visible YouTube player, service worker updated to exclude YouTube from caching.
</objective>

<execution_context>
@/Users/user/.claude/get-shit-done/workflows/execute-plan.md
@/Users/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-audio-foundation/01-RESEARCH.md
@index.html
@sw.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update service worker to exclude YouTube domains</name>
  <files>sw.js</files>
  <action>
Modify `sw.js` to exclude YouTube-related domains from the cache-first strategy. This prevents stale YouTube API scripts from being served.

1. Bump `CACHE_NAME` from `'pomodoro-v33'` to `'pomodoro-v34'`.

2. Replace the existing fetch handler (lines 20-24) with one that checks the request URL hostname before caching. If the hostname includes `youtube.com`, `youtube-nocookie.com`, `googlevideo.com`, or `ytimg.com`, respond with a fresh network fetch (no caching). Otherwise, use the existing cache-first strategy (`caches.match` then `fetch`).

The existing fetch handler is:
```javascript
self.addEventListener('fetch', (e) => {
  e.respondWith(
    caches.match(e.request).then((cached) => cached || fetch(e.request))
  );
});
```

Replace with:
```javascript
self.addEventListener('fetch', (e) => {
  const url = new URL(e.request.url);

  // Never cache YouTube/Google Video domains
  if (url.hostname.includes('youtube.com') ||
      url.hostname.includes('youtube-nocookie.com') ||
      url.hostname.includes('googlevideo.com') ||
      url.hostname.includes('ytimg.com')) {
    e.respondWith(fetch(e.request));
    return;
  }

  e.respondWith(
    caches.match(e.request).then((cached) => cached || fetch(e.request))
  );
});
```
  </action>
  <verify>Read sw.js and confirm: (1) CACHE_NAME is 'pomodoro-v34', (2) fetch handler contains YouTube domain exclusion check before cache-first logic.</verify>
  <done>Service worker excludes YouTube domains from caching and cache version is bumped to v34.</done>
</task>

<task type="auto">
  <name>Task 2: Add YouTube player integration to index.html</name>
  <files>index.html</files>
  <action>
This task adds four things to index.html: (A) HTML player container, (B) CSS styles, (C) JavaScript YouTube API integration with play/pause, (D) a play/pause toggle button in the UI.

**IMPORTANT constraints:**
- YouTube ToS requires the player be visible and at least 200x200px when audio is enabled
- Autoplay must be 0 (user interaction required for first play)
- `playsinline: 1` is critical for iOS
- The global callback `window.onYouTubeIframeAPIReady` must be explicitly assigned to `window` (not declared as function) because the app code is inside an IIFE
- Default video: `jfKfPfyJRdk` (Lofi Girl 24/7 stream)
- Phase 1 does NOT include: volume slider, mute/unmute, categories, playlists, auto-pause on break, ducking

**A. HTML: Add player container and audio toggle button**

1. Add an audio toggle button in the timer controls area. Find the existing timer controls (the `div.timer-controls` containing `startBtn`, `pauseBtn`, `resetBtn` — around line 1370-1380). Add an audio toggle button AFTER the `resetBtn` button, inside the same `.timer-controls` div:

```html
<button class="icon-btn audio-toggle" id="audioToggle" aria-label="Toggle background audio" data-tooltip="Background audio">
  <svg class="audio-icon-off" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M11 5L6 9H2v6h4l5 4V5z"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/>
  </svg>
  <svg class="audio-icon-on hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
    <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
    <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
  </svg>
</button>
```

2. Add the YouTube player container div. Place it right AFTER the `<div id="celebrationContainer"></div>` (around line 1426), BEFORE the `<dialog id="settingsDialog"...>`:

```html
<div id="youtube-player-container" class="youtube-player-wrapper"></div>
```

**B. CSS: Add styles for player wrapper and audio toggle**

Add these styles in the `<style>` section (a good location is near the end of the CSS, before the closing `</style>` tag, around line 1300). Use existing CSS custom properties where available.

```css
/* --- Audio --- */
.youtube-player-wrapper {
  position: fixed;
  bottom: 80px;
  right: 20px;
  width: 200px;
  height: 200px;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  display: none;
  z-index: 100;
  transition: opacity 0.3s ease;
}

.youtube-player-wrapper.visible {
  display: block;
}

.youtube-player-wrapper iframe {
  width: 100%;
  height: 100%;
  border: 0;
}

.audio-toggle {
  position: relative;
}

.audio-toggle.active {
  color: var(--primary);
}

@media (max-width: 480px) {
  .youtube-player-wrapper {
    bottom: 70px;
    left: 50%;
    right: auto;
    transform: translateX(-50%);
  }
}
```

**C. JavaScript: YouTube API integration**

All JS goes inside the existing IIFE. Add code in these specific locations:

**C1. Add `audio` storage key** — In the `STORAGE_KEYS` constant (around line 1584), add:
```javascript
audio: 'pomodoro-audio',
```

**C2. Add `audioToggle` DOM ref** — After the existing DOM refs (around line 1651, after `const taskCount = ...`), add:
```javascript
const audioToggle = $('#audioToggle');
const audioIconOff = $('.audio-icon-off');
const audioIconOn = $('.audio-icon-on');
const youtubePlayerWrapper = $('.youtube-player-wrapper');
```

**C3. Add `audio` to state object** — In the `state` object (after `tasks: []` on line 1678), add:
```javascript
audio: {
  enabled: false,
  playing: false,
  volume: 50,
  currentVideoId: 'jfKfPfyJRdk',
},
```

**C4. Add audio storage functions** — After `saveTasks()` (around line 1724), add:
```javascript
// --- Audio ---
function loadAudioSettings() {
  try {
    const raw = localStorage.getItem(STORAGE_KEYS.audio);
    if (raw) {
      const saved = JSON.parse(raw);
      state.audio.enabled = saved.enabled ?? false;
      state.audio.volume = saved.volume ?? 50;
    }
  } catch {}
}

function saveAudioSettings() {
  localStorage.setItem(STORAGE_KEYS.audio, JSON.stringify({
    enabled: state.audio.enabled,
    volume: state.audio.volume,
  }));
}
```

**C5. Add YouTube player management** — After the audio storage functions (so right after `saveAudioSettings`), add the YouTube player management block. This is the core of the integration:

```javascript
// --- YouTube Player ---
let youtubePlayer = null;
let youtubeAPIReady = false;
let youtubeInitQueue = [];

// CRITICAL: Global callback bridge for IIFE
window.onYouTubeIframeAPIReady = function() {
  youtubeAPIReady = true;
  while (youtubeInitQueue.length > 0) {
    const initFn = youtubeInitQueue.shift();
    initFn();
  }
};

function loadYouTubeAPI() {
  if (window.YT || document.querySelector('script[src*="youtube.com/iframe_api"]')) {
    if (window.YT && window.YT.Player) {
      youtubeAPIReady = true;
    }
    return;
  }
  const tag = document.createElement('script');
  tag.src = 'https://www.youtube.com/iframe_api';
  const firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
}

function initYouTubePlayer() {
  if (!youtubeAPIReady) {
    youtubeInitQueue.push(initYouTubePlayer);
    return;
  }
  if (youtubePlayer) return;

  youtubePlayer = new YT.Player('youtube-player-container', {
    height: '200',
    width: '200',
    videoId: state.audio.currentVideoId,
    playerVars: {
      autoplay: 0,
      controls: 1,
      disablekb: 1,
      fs: 0,
      modestbranding: 1,
      playsinline: 1,
      rel: 0,
      enablejsapi: 1,
    },
    events: {
      onReady: onPlayerReady,
      onStateChange: onPlayerStateChange,
      onError: onPlayerError,
    },
  });
}

function onPlayerReady(event) {
  event.target.setVolume(state.audio.volume);
  // If user had already clicked play before player was ready, start playing
  if (state.audio.playing) {
    event.target.playVideo();
  }
}

function onPlayerStateChange(event) {
  if (event.data === YT.PlayerState.PLAYING) {
    state.audio.playing = true;
    updateAudioUI();
  } else if (event.data === YT.PlayerState.PAUSED) {
    state.audio.playing = false;
    updateAudioUI();
  } else if (event.data === YT.PlayerState.ENDED) {
    // For Phase 1, just replay the same video (loop)
    if (youtubePlayer && typeof youtubePlayer.seekTo === 'function') {
      youtubePlayer.seekTo(0);
      youtubePlayer.playVideo();
    }
  }
}

function onPlayerError(event) {
  console.error('YouTube player error:', event.data);
  state.audio.playing = false;
  updateAudioUI();
}

function toggleAudio() {
  if (!state.audio.enabled) {
    // First time enabling audio: load API and init player
    state.audio.enabled = true;
    saveAudioSettings();
    loadYouTubeAPI();
    initYouTubePlayer();
    youtubePlayerWrapper.classList.add('visible');
    // Set playing intent — player will start when ready
    state.audio.playing = true;
    updateAudioUI();
  } else if (state.audio.playing) {
    // Pause
    if (youtubePlayer && typeof youtubePlayer.pauseVideo === 'function') {
      youtubePlayer.pauseVideo();
    }
    state.audio.playing = false;
    updateAudioUI();
  } else {
    // Resume
    if (youtubePlayer && typeof youtubePlayer.playVideo === 'function') {
      youtubePlayer.playVideo();
    }
    state.audio.playing = true;
    // Show player wrapper in case it was hidden
    youtubePlayerWrapper.classList.add('visible');
    updateAudioUI();
  }
}

function updateAudioUI() {
  if (state.audio.playing) {
    audioIconOff.classList.add('hidden');
    audioIconOn.classList.remove('hidden');
    audioToggle.classList.add('active');
  } else {
    audioIconOff.classList.remove('hidden');
    audioIconOn.classList.add('hidden');
    audioToggle.classList.remove('active');
  }
}
```

**C6. Add audio toggle event listener** — In the event listeners section (after line 2547, near the other button listeners), add:
```javascript
audioToggle.addEventListener('click', toggleAudio);
```

**C7. Add `loadAudioSettings()` to `init()`** — In the `init()` function (around line 2710), add `loadAudioSettings();` after `loadTasks();` and before `renderTasks();`. Also, if audio was previously enabled, restore the player:

After `loadAudioSettings();`, add:
```javascript
if (state.audio.enabled) {
  loadYouTubeAPI();
  initYouTubePlayer();
  youtubePlayerWrapper.classList.add('visible');
}
```

**Order of additions in the JS section:**
1. STORAGE_KEYS addition (line ~1588)
2. DOM refs (line ~1652)
3. State audio property (line ~1679)
4. Audio storage functions (after saveTasks, ~line 1724)
5. YouTube player management (after audio storage)
6. Event listener (in event listeners section)
7. Init additions (in init function)
  </action>
  <verify>
1. Read index.html and confirm:
   - `youtube-player-container` div exists in HTML body
   - Audio toggle button with id `audioToggle` exists in timer controls
   - CSS class `.youtube-player-wrapper` exists with `width: 200px; height: 200px`
   - `state.audio` exists with `enabled`, `playing`, `volume`, `currentVideoId`
   - `window.onYouTubeIframeAPIReady` is assigned (not declared)
   - `toggleAudio()` function exists and handles enable/play/pause states
   - `loadAudioSettings()` is called in `init()`
   - Audio toggle event listener is registered
2. Grep for `STORAGE_KEYS` and confirm `audio: 'pomodoro-audio'` is present
3. Grep for `youtubePlayer` and confirm player management code exists
  </verify>
  <done>
YouTube player integration is complete in index.html: HTML container placed in body, CSS styles for 200x200px visible player, JavaScript with YouTube IFrame API loading, IIFE-compatible global callback bridge, play/pause toggle, state management, localStorage persistence, and init restoration.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify audio playback works</name>
  <what-built>YouTube-based background audio with play/pause toggle and visible 200x200px player.</what-built>
  <how-to-verify>
1. Open `index.html` in a browser (or run a local server: `python3 -m http.server 8000` from the project root)
2. The page should load normally with NO YouTube player visible initially
3. Find the audio toggle button (speaker icon) in the timer controls area
4. Click the audio toggle button:
   - The YouTube player (200x200px) should appear at the bottom-right of the screen
   - The Lofi Girl stream should begin playing (may take a moment to buffer)
   - The speaker icon should change to show audio waves
5. Click the audio toggle button again:
   - Audio should pause
   - Speaker icon should show the "off" state (X through speaker)
6. Click again to resume — audio should resume playing
7. Verify the player is visible and at least 200x200px (YouTube ToS compliance)
8. On mobile viewport (resize browser to < 480px): player should center at bottom
9. Refresh the page — if audio was enabled before refresh, the player should reappear (audio settings persisted)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Service worker (`sw.js`): Cache version bumped to v34, YouTube domains excluded from caching
2. YouTube player container exists in HTML body with proper ID
3. Audio toggle button exists in timer controls with play/pause SVG icons
4. CSS styles define `.youtube-player-wrapper` at 200x200px fixed position
5. JavaScript YouTube API loads dynamically on first audio enable
6. Global callback `window.onYouTubeIframeAPIReady` properly bridges IIFE scope
7. `state.audio` tracks enabled/playing/volume/currentVideoId
8. Audio settings persist to localStorage via `pomodoro-audio` key
9. `toggleAudio()` handles three states: initial enable, pause, resume
10. Player auto-restores on page load if previously enabled
</verification>

<success_criteria>
- User clicks audio button and hears Lofi Girl background audio
- User clicks again to pause, again to resume
- YouTube player is visible at 200x200px (ToS compliant)
- Audio settings persist across page refresh
- No console errors during normal playback
- Service worker does not cache YouTube resources
</success_criteria>

<output>
After completion, create `.planning/phases/01-audio-foundation/01-01-SUMMARY.md`
</output>
